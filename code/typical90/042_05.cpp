#include <bits/stdc++.h>
using namespace std;
#define rep(i, n) for (int i = 0; i < (n); i++)
using ll = long long;

// https://atcoder.jp/contests/ddcc2020-qual/tasks/ddcc2020_qual_d?lang=ja

// 🔷初見でどうやったら解けるか
// 制約条件より、O(N)もだめなので衝突問題のような法則性がある可能性が高いと考える。
// 故に実験する。ありうる状態は、(1)桁が変化しない場合と、(2)1つ減る場合の2通り。
// ここで本問題は典型的なリソース消費型問題であり、操作によって消費されるリソースは0か1である。
// 故にリソースを消費する操作は合計で丁度n回行う必要がある。後はリソースを消費しない操作が何回行われるか計算できる指標を見つければ良い。
// 局所的な桁和ではうまく表現できそうにないので、大局的な桁和を考えるとうまくいくことがわかる。

// 🔷抑えるべき抽象論は？
// 法則性を見抜くための実験の心得
// - 状態のパターンをそれぞれ考える
//   - 多くは複数の状態の和を取る形
// リソース消費型操作
// - 消費単位が0か1の場合は、1消費する操作は必ず丁度リソース分行う必要がある

int main() {
    int m; cin >> m;
    ll digits = 0, sum = 0;
    rep(i, m) {
        ll c, d; cin >> d >> c;
        sum += d * c;
        digits += c;
    }

    // 桁数が変化する場合
    ll ans = digits - 1;

    // 桁数が変化しない場合
    ans += (sum - 1) / 9;
    cout << ans << endl;
}
