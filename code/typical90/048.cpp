#include <bits/stdc++.h>
using namespace std;
#define rep(i, n) for (int i = 0; i < (n); i++)
using ll = long long;

// 🔷初見でどうやったら解けるか
// 組合せ最適化問題を貪欲法で解く典型問題
// 全探索→貪欲法→dp→グラフ→二分探索 の順に基本は考えていく
// 得点の大小に関わらずコスト(所要時間)が一定であることが貪欲性を保証する

// 🔷抑えるべき抽象論は？
// 貪欲性が成立する条件として、「コスト関数と目的関数がそれぞれの最適化方向に対して広義単調性をもつ」がある
// 本問題は「一定」なので広義単調性を満たす

// 🔷類問を考える
// 問題によって異なった所要時間が与えられる問題
// → 単調性は不成立なので貪欲は無理
// → 所要時間の制約下で得点を最適化するので、ナップサックdpと同じ構造。dp[i問目までみる][j分使う]:=得点の最大値 としてdp[n][k]を求める
//   - 順序を導入でき、閉路が存在しないこと
//   - 累積的な依存関係が成立すること

int main() {
    int n, k; cin >> n >> k;
    vector<int> p;
    rep(i, n) {
        int a, b; cin >> a >> b;
        p.push_back(b);
        p.push_back(a - b);
    }
    sort(p.rbegin(), p.rend());

    ll ans = 0;
    rep(i, k) ans += p[i];
    cout << ans << endl;
}
