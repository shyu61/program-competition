#include <bits/stdc++.h>
using namespace std;
#define rep(i, n) for (int i = 0; i < (n); i++)
using ll = long long;

// 🔷初見でどうやったら解けるか
// 括弧列の構築問題かつ組合せ最適化問題。明らかに括弧列の構築制約が大きいので、どうやって構築するかから考える。
// 構築方法は色々あるがdpを使う方法と、前から2個ずつ見ていく方法が有力な選択肢。dpはO(n^2)かかるので除外。
// 前から2個ずつ見ていくことを考えると、貪欲に値が大きいものを選んでいけば良いだけだとわかる。

// 🔷抑えるべき抽象論は？
// 正しい括弧列と判定する,構築する方法は何種類かある。制約や欲しい情報に応じて使い分ける。
// 正しい括弧列
// 1. 判定が容易,構築に使うには大変
//   - (を1,)を-1とした時、いずれの点でも累積和が0以上
//   - 末尾での累積和が0,もしくは(と)が同数
//   -> 構築するなら、動的に全ての点の累積和が0以上か判定する必要がある。
//     - 区間minが分かれば良いのでrmqを使う
//     - ある点の変更の影響はそれ以降全てに及ぶので区間更新も必要なのでlazy_segtreeで。
// 2. 構築向き
//   - 1番目までで(が1個以上,3番目までで(が2個以上,...k番目までで(がk/2+1個以上
//   - (と)が同数
// 3. 特殊な条件下での構築などに有効。O(n^2)かかる
//   - dp[i][j]:=i番目まで見た時、(と)の個数の差がjの場合の通り数(他、合計最大値など)
// 全てでx以上 -> 全区間のminがx以上
// 少なくとも1つがx以上 -> 全区間のmaxがx以上

// 🔷類問を考える
// 括弧列と同じような制約を持つ配列問題
// - 要素が1,-1で、いずれの点でも累積和が0以上出ないといけない配列を構築するような問題
// - 逆に言えば、一次元配列でも制約が同じであれば括弧列問題とみなせるということ

int main() {
    int t; cin >> t;
    while (t--) {
        int n; cin >> n;
        int n2 = n * 2;
        vector<int> a(n2);
        rep(i, n2) cin >> a[i];

        priority_queue<ll> pq;
        ll ans = 0;
        rep(i, n2) {
            pq.push(a[i]);
            if (i % 2 == 0) {
                ans += pq.top(); pq.pop();
            }
        }
        cout << ans << '\n';
    }
}
