#include <bits/stdc++.h>
using namespace std;

// 思考フロー
// 目標は削除頂点の最小化なので、所与の木から逐次的に頂点を削除し、都度ユ木判定をするのがナイーブ
// -> しかしユ木の判定が大変かつ、削除頂点を効果的に探索するのが難しい
// -> 常に補集合もセットで選択肢にあげることを考えると、0ベースで最大サイズのユ木を構築することを考えてみる
// -> ユ木は構造が明確で構築しやすい。中心を決めて、xを決めて、yを決めることを考える
// -> 中心が決まればxの候補は決まる。xが決まればyは決めることができる。

// ポイント
// - 常に対になる操作(補集合を考えること)を選択肢にあげる
//   - 最小の削除によるユ木の構築 <=> 最大サイズのユ木の構築
//   - 「何を求める必要があるか？」「どの操作が複雑か」「補集合を考えることでシンプルにならないか」
//     - 以上から目的を再定義する
// - 探索空間を適切に見極める
//   - 考慮しなくて良い部分はないか？
// - 計算量見積もりについて
//   - 外側のループに伴って探索範囲が変化するような処理を内側に含んでいる場合は特に注意する

int main() {
    int N; cin >> N;
    vector<vector<int>> G(N);
    for (int i = 0; i < N - 1; i++) {
        int u, v; cin >> u >> v;
        u--; v--;
        G[u].push_back(v);
        G[v].push_back(u);
    }

    int ans = N;
    for (int c = 0; c < N - 1; c++) {  // O(N)
        int m = G[c].size();
        vector<int> xs(m);
        for (int i = 0; i < m; i++) {
            int ch = G[c][i];
            xs[i] = G[ch].size();
        }
        sort(xs.rbegin(), xs.rend());  // O(mlogm)

        for (int i = 0; i < m; i++) {
            int x = i + 1;
            int y = xs[i] - 1;
            ans = min(ans, N - (x + x * y + 1));;
        }
    }  // Σi=0...N-1 (m) = 2(N-1) より全体はO(NlogN)になる
    cout << ans << endl;
}
