// Millionaire: p123
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

// 目的はあらゆる賭けパターンを試した時に、ミリオネアになる最大確率を求めること。
// 明らかに逐次問題でありDPだと予想できる。
// 問題は状態をどう持つかだが、あらゆる賭けパターンは連続値であり状態として持てないため、離散値に変換できないか考える。
// （連続値は基本扱えないと考えた方が良い、正規化して離散化するのが鉄則）
// とりうるパターンが区間で決まっており離散化できることがわかる。（とりうる場合の数は2^Mなのでdp[M][(1<<M)+1]とする）
// よって状態はラウンド数と所持金を持ち、各ラウンドで賭けうる全てのパターンを試せば良いことがわかる。

// あとはdpテーブルを埋めるようにループを回しつつ、そのループ内で遷移を記述すれば良い。
// 最終ラウンドから考えると良いため、dpは逆向きに埋める。遷移条件は、j賭けた場合の勝ち負け両方の遷移を未来から過去に向けて行う。
// 勝つ場合は、未来においてdp[i+j]になっている。現在の所持金がiの状態で未来この状態になるにはP確率が必要になる。
// 思考の順番としては、最終ラウンドから考えないと求められない -> 逆向き遷移DPを考える -> 未来の情報を使って今を計算する遷移式を書く

// DPにおいて遷移の方向は非常に重要、例えばTSPも後ろ向き遷移をする。
// 特に今回のように全探索的な考え方をする場合、根から葉の方向にかけて状態が遷移する。

int main() {
    int T; cin >> T;
    for (int t = 0; t < T; t++) {
        int M, X;
        double P;
        cin >> M >> P >> X;
        int n = 1 << M;

        // dp[残りラウンド][所持金]
        vector<vector<double>> dp(M + 1, vector<double>(n + 1));
        dp[0][n] = 1;
        // ラウンドを進める
        for (int r = 0; r < M; r++) {
            for (int i = 0; i <= n; i++) {
                // 勝った時にnを超えないようにする
                int jub = min(i, n - i);
                double t = 0;
                for (int j = 0; j <= jub; j++) {
                    // 勝つ場合: 確率=P, 金額=i+j
                    // 負ける場合: 確率=1-P, 金額=i-j
                    t = max(t, P * dp[r][i + j] + (1 - P) * dp[r][i - j]);
                }
                // r+1ラウンド目で、金額iを持っていた時のMillion確率
                dp[r + 1][i] = t;
            }
        }

        int i = ll(X) * n / 1e6;
        cout << "Case #" << t + 1 << ": " << fixed << setprecision(9) << dp[M][i] << endl;
    }
}
