// デックの利用(K-Anonymous Sequence): p304
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

// dp高速化を考える問題
// dp高速化は色々あり区間アルゴリズムを使うものが多いが、これは直線群の幾何学的性質を利用する方法
// Convex Hull Trick: 複数の線形関数の中から直線x=xにおけるmin/maxを高速に求めるアルゴリズム

// 思考フロー
// まずは目的と制約を整理する。制約として"減少"しかできないので明らかにこの数列は、前から順番に処理していくことになる。
// -> 逐次操作系問題であり、k-Anonymousを作るのにかかるコストは自身より前までの数列により累積的に決まる構造なので、dpが適切なアプローチだと気付く
// -> 基本通りナップサックdpで考える。`dp[i] := 0からi番目までをk-anonymousにする最小コスト`とする
// ここで重要なのは、ナップサックdpはi番目までしか考慮してはいけないこと。
// つまりiを挟むようにk-anonymousを作るようなケースはi番目より後の項を考慮してしまうのでここでは考慮してはいけない
// -> 故にi番目で条件を満たすにはi番目より手前の少なくともk-1個の値にi番目を減算する必要がある
// -> dp[i] = min{dp[j] + (a[j+1]-a[j]) + (a[j+2]-a[j]) + ... + (a[i-1]-a[j]) | 0<=j<=i-k}
// -> i,j,遷移でO(n^3)なので全然間に合わない。dpの高速化処理が必要だと気付く
// -> dpの高速化と言えば、区間アルゴリズムや線形min/maxをまず検討する
// -> 明らかに累積和を含むので事前計算できる。dp[i] = min{dp[j] + S[i] - S[j] - a[j] * (i - j) | 0<=j<=i-k}
// -> これでO(n^2)なのでまだ不十分。minとくれば区間か線形を考える。minの中身はiについて線形なのでconvex-hull-trickが使える形であることに気付く
// 凸包trickは、min関数部分を、直線集合(区間内の各点における)と見るので、区間変数であるjは定数と見る
// つまり変数jをO(n)分走査せずに、一度に考え幾何学的に処理することで効率化を図っている
// -> 一次関数部分はできるだけシンプルにしたいので、関係ない項は外に出すと、dp[i] = min{-a[j] * i + (dp[j] - S[j] + a[j] * j)} + S[i]
// -> fj(x) = -a[j] * x + (dp[j] + S[j] + a[j] * j)とおいた時に、この直線集合のx=iにおける最小値を求めれば良い
// -> 幾何学的性質を使うと、**傾きが単調関係にある3直線について、2番目の傾きの直線が冗長かどうかを交点の位置関係より判定できる。**

// convex-hull-trickのポイント
// - 代数を幾何学的性質から高速化している
// - 更新(直線の追加)
//   - スライド最小化と同様に冗長な値(直線)は保持しないという戦略
//     - 冗長判定には「傾きの単調性」が必要
//       - 元々単調性が保証されるならdequeが使える
//       - 単調性が保証されないならBSTでソートしておく
// - クエリ
//   - 冗長な直線がない時、最小値を与える直線群の傾きは単調減少するという幾何学的性質を利用する
//     - dequeの場合: 先頭を取るだけ(傾きの単調性が保証されるので、deque内は傾き順にソートされているため)
//   - BSTの場合:
//     - 変化点として機能する隣接直線同士の交点のx座標は単調増加であることから、x=iが属する交点区間を二分探索し、最小値を与える直線を特定する

vector<int> a;
vector<ll> S, dp;

// fj(x)のxにおける値
ll f(int j, int x) {
    return -a[j] * x + dp[j] - S[j] + a[j] * j;
}

// m1>m2>m3の条件下で、2交点の位置関係からf2が冗長かを判定する
bool check(int f1, int f2, int f3) {
    ll a1 = -a[f1], b1 = dp[f1] - S[f1] + a[f1] * f1;
    ll a2 = -a[f2], b2 = dp[f2] - S[f2] + a[f2] * f2;
    ll a3 = -a[f3], b3 = dp[f3] - S[f3] + a[f3] * f3;
    return (a2 - a1) * (b3 - b2) >= (b2 - b1) * (a3 - a2);
}

int main() {
    int n, k; cin >> n >> k;
    a = vector<int>(n);
    S = dp = vector<ll>(n + 1);
    for (int i = 0; i < n; i++) cin >> a[i];

    for (int i = 0; i < n; i++) {
        S[i + 1] = S[i] + a[i];
    }

    deque<int> deq;  // fj(x)のjを保存。fj(x)がminになり得ない場合は削除していく
    for (int i = k; i <= n; i++) {
        // 幾何学的性質より傾きが単調関係である3直線における真ん中の直線の冗長性を判定する
        while (deq.size() >= 2 && check(deq[deq.size() - 2], deq[deq.size() - 1], i - k)) deq.pop_back();
        deq.push_back(i - k);

        // 先頭が最小値でなければ取り除く
        // 直前の状態ではdeq.front()が最小だが、iを1つ進めた時に最小値が変化するかどうかは調べないとわからない
        while (deq.size() >= 2 && f(deq[0], i) >= f(deq[1], i)) deq.pop_front();

        // dp[i] = S[i] + min{fj(x)}
        // deq.front()は、fj(x)を最小にするj
        dp[i] = S[i] + f(deq.front(), i);
    }
    cout << dp[n] << endl;
}
