// ゲームと必勝法(Euclid's Game): p275
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

// 思考フロー
// ゲーム問題の定石はDP -> DPが適用できる条件は、状態空間が大きすぎないことと、最終状態から逆方向遷移が記述できること
// 本問題ではa,b<2^31の時点で無理 -> 何らかの法則性を見抜く必要がある
// -> セオリー通り本質的な自由度を調べると、b-a>aの時はa,bの大小が入れ替わるまで引くかどうかの自由度2, b-a<aの時は自由度1
// -> 自由度1の場合は次の状態での勝負に依存し、自由度2は勝敗に応じて選び分けられるので必勝になる

// 法則を見抜く上でのポイント(DPが無理な時)
// - 対称構造がないか？: 操作のミラーリングが最適操作になることがしばしばある
// - 各操作の自由度を調べる: 本質的な自由度(勝敗に影響を与えるような操作の種類)は？
// - (勝敗の決定条件は？)
// - 実験して法則性を見抜く

int main() {
    int a, b; cin >> a >> b;

    bool f = true;
    while (1) {
        if (a > b) swap(a, b);  // a,bは対称なので固定してしまう方が楽。もちろんa,bの大小で条件分岐してもok
        if (b % a == 0) break;
        if (b - a > a) break;
        b -= a;
        f = !f;
    }

    cout << (f ? "Stan wins" : "Ollie wins") << endl;
}
