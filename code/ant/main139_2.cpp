// ダブリング: p307
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

// 遷移テーブルを作る時に、「s,t混合の配列ソートを考える」ことと「後ろからの遷移を考える」をどう思いつくか？
// - 貪欲法の遷移条件は「t[i]<=s[j]を満たすjのうちt[j]が最小のもの」なので、sとtの比較が発生する。ゆえにs,t混合ソートが良いことは直感的
//   => 区間の位置関係を扱うときはs,t混合配列をソートするのは典型パターン
// - 作っているのは"遷移テーブル"なので、やってることはdpとほぼ一緒。dpは前後どっちからの遷移が適切か考えるのは当たり前。
//   今回も前からの遷移がO(n^2)になってしまうことはすぐ分かるので、後ろからはどうか？と考えるのは自然
//   - ちなみに後ろからの遷移を考える本質的な理由は、「探索範囲をすでに見た範囲に限定する」ことで、解の候補を保持しておくことができるから。
//     スライド最小化も同じ性質を利用している。判定条件的に明らかに後ろの区間を調べる必要があるが、それを逆手に後ろから見ていけば、
//     探索範囲がすでに走査した範囲になるので、候補を持っておくことができればO(1)で処理ができそうと予想できる

// ポイント
// - 区間の位置関係を考えるときはs,t混合ソートを考えると良い
// - 遷移テーブルは前後どっちから埋めるのが良いかちゃんと考える
//   - 探索範囲をすでに走査済み範囲にすることができれば、スライド最小化と同じ理由でO(n)にできる


int main() {
    int N, M; cin >> N >> M;
    vector<int> s(N * 2), t(N * 2);
    for (int i = 0; i < N; i++) cin >> s[i] >> t[i];

    // 複製
    for (int i = 0; i < N; i++) {
        if (t[i] < s[i]) t[i] += M;
        s[N + i] = s[i] + M;
        t[N + i] = t[i] + M;
    }

    // 区間の端点をソート
    vector<pair<int, int>> ps(N * 4);
    for (int i = 0; i < N * 2; i++) {
        ps[i] = make_pair(t[i], i);
        ps[N * 2 + i] = make_pair(s[i], N * 2 + i);
    }
    sort(ps.begin(), ps.end());

    vector<int> next(N * 2);  // next[i] := j, iの次の区間がj
    int last = -1;
    for (int i = N * 4 - 1; i >= 0; i--) {
        int id = ps[i].second;
        if (id < N * 2) {  // idはtである
            next[id] = last;
        } else {  // idはsである
            id -= N * 2;
            // t[i]<=s[j]を満たす必要があるので、新たなs[j]が現れた時点で更新が検討される
            // 実際更新されるのは、その時のtがより小さくなる場合
            if (last < 0 || t[last] > t[id]) last = id;
        }
    }

    int ans = 0;
    for (int i = 0; i < N; i++) {
        int res = 0;
        for (int j = i; t[j] <= s[i] + M; j = next[j]) res++;
        ans = max(ans, res);
    }
    cout << ans << endl;
}
