## ジャンル別
#### 数論
- 剰余が絡む問題
- 約数,割り切る等が絡む問題
  - 倍数判定
  - 素数判定
  - 素因数分解
- 周期性が絡む問題
  - まず最初に「周期内での位置」と「何周期目か」を考える
- 桁が絡む問題
  - 桁dp
  - 桁dpの枠組みで法則的に解く
  - 全体を数字として扱えない場合も多い。桁ごとに配列や文字列で扱い繰り上げ処理を行うことを考える
- 組合せ系
  - グループ化(パーティション)はベル数もしくはスターリング数を使う

#### 区間処理問題
- 区間伸縮が高速に行える場合
  - 尺取り法, mo's
- 区間mergeが高速に行える場合
  - segtree系, fenwicktree, バケット法
- 区間に単調性を導出できる場合
  - 二分探索(判定問題帰着)
    - 単調性配列を事前計算しておく
- その他: 累積和
- 区間更新
  - 更新区間が連続で重複がない場合は、端点情報さえ持てば十分
  - lazysegtree
- テクニック
  - 直接解を持たせる方法と間接情報を持たせる方法がある
  - 多くの場合で事前計算が絡む
  - 全体が配列で、分割して区間を作る類の問題は、番兵を使うと最終区間を例外なく扱える

#### クエリ問題
- 何を事前計算するかが肝
- クエリの種類が複数がる場合は、何を高速化する必要があるかをまず特定する
- アプローチ方法は大きく2つ
  - 事前計算方式
    - クエリ計算量: O(1)
    - usecase: 静的クエリ,与えられるクエリの範囲が全計算できる場合
    - クエリで与えられる全範囲に対して結果をあらかじめ計算しておく
  - 部分事前計算
    - クエリ計算量: O(logN)
    - usecase: 動的クエリにも対応できる
    - 代表値を保持するデータ構造(segtree,fenwicktree)、あるいは二分探索や累積性が利用できるような配列を作っておく(累積和,単調性配列など)
  - 順序最適化方式
    - クエリをソートして隣接するクエリ間で共通する計算部分を再利用する方法
    - mo's,尺取り法など

#### 組合せ最適化問題
- 全探索
  - 組み合わせ制約が隣接要素間の場合は区間アルゴリズムなども使える
- 貪欲法
  - まずは考えやすい特定の条件下で実験してみる
  - コスト関数と目的関数がそれぞれの最適化方向に対して広義単調性をもつ
    - ナップサック問題と類似の構造を持つ場合はこれをチェックすると良い
    - 「価格が安いほど価値が小さくない」
- dp
  - 遷移の方向を規定できる(eg.文字列,逐次問題など)
  - 影響が累積的
- グラフ
  - 大前提、nwフロー系以外で使えるケースは限定的
  - グラフ化した時に木やfunctionalグラフにならないかまず考える
    - これらはdpに帰着できる
  - 組合せ制約が任意の要素間に及び、直接dpの適用が難しいケース
- 判定問題帰着
  - 直接最適性を求めるのは難しいが、判定は高速に行える場合
  - 最小の最大化
  - 複数種類を同時最適化する場合
    - 部分問題間の依存性が弱い場合は判定問題で解ける(判定問題にすることで独立に扱える)
      - 部分問題間の依存性が弱いとは: 合計値やリソース総量などの関係性のみの場合
- 補集合を考える
  - 最小化は逆の操作の最大化の方が簡単だったりしないか？
    - eg) 削除回数の最小化->最大構築サイズ
- ダブリング
  - 各要素が独立に選択可能で、同種の要素が複数あるとき、塊で扱うという考え方ができる

#### 逐次問題
- 貪欲法
- dp
- グラフ
- データ構造
  - stack+popは単調性作出に便利
- ダブリング
  - 目的地まで一気に進めるという考え方
- テクニック
  - 求める時刻はいつか？
    - 全ての時刻
    - クエリで与えられた時刻
    - 無限時間後
      - 順序依存性がない時、逐次操作をtrackする必要はなく、バッチ的に求められることが多い
  - 未来への影響管理
    - ある時点の影響が未来に及ぶ時、未来に対して情報を先に記録する/遅延する
  - 過去への影響管理
    - ある時点の過去全てを更新するような操作の場合は、引き算で逆に考える(時刻を保持させて、現在時刻から引くことで算出する)
  - 変化する対象が複数ある場合
    - 順序構造が変化することがあるか確認する
    - 影響がある(考慮する必要がある)対象を特定する
  - 逆順に考えた方が良いケースもある
    - 最終的な状態から操作を取り消していくことを考える
    - 挿入操作 <=> 削除操作 考えやすい方に注目する

#### 数え上げ
- 単調性が条件にある場合: 二分探索が使えるデータ構造を使う
  - 静的: vectorをsort
  - 動的かつ削除可: set,multiset,priority_queue
    - left,rightを指定したいならset, leftは常に先頭でrightを指定したいならpriority_queue
  - 動的かつ削除不可: fenwick_tree
- 区間数え上げ
  - 使えるテクニック: offset
- カウント配列
- 全ペア数え上げ問題
  - そもそもペアの生成が間に合わない場合
    - 逆転の発想をする
      - 全ペアを走査して条件を満たすものを数え上げる <=> 全条件を走査してそれに合致するペアを数え上げる
    - 対称なものをまとめて計算する
      - 剰余が絡むなら余りで分類すると良い
    - 最終求めるものの形式に合わせて使えそうな高速化を念頭におく
      - eg) 総和を求める問題なら、累積和とか使えるかも？と考える
  - 各クエリが間に合わない場合
  - 各要素の値が連続なら、格子点とみなせる
    - 各格子点へのパスを限定することで計算量を落とせる場合がある
- 補集合を考える
  - 特にnot条件が絡む場合
- 条件がかつの場合、条件的に厳しいのはどちらか？を考えると良い

#### 構築問題
- 解が一意の場合
- 解が無数にある場合
  - 全列挙なら法則を見抜いて全探索する
  - 1つで良いなら最も考えやすい形について調べる

#### ゲーム問題
- 基本方針
  - 各局面の状態の表現方法を考える
    - 存在性: 2進数
    - 存在場所,より詳細な状態など3値以上のパターンを取りうる場合: 3進数, 各パターンをtupleで別々にvectorなどで保持
  - メモ化再帰 f(s):=状態sからスタートして遷移先で、少なくとも1つ相手が負ける選択肢があるか を定義する
    - 状態sで操作しうる選択肢を全探索する

#### 確率,期待値問題
- 「独立性」を考えることが最も重要
  - どの操作とどの操作が独立なのか、状態に依存するのか、その状態はどう遷移するのか
- 確率問題
  - 基本系: `dp[i] = Σj(dp[j]*Pj)`
  - 純粋に場合の数を数え上げる問題も存在する。制約を常に注視する。
  - 「一様性の仮定」を疑うこと
    - 重複や同一性がある場合は特に注意
    - dpを使う問題など、操作結果が状態に依存する問題も一様性が成立しない典型
- 期待値問題
  - 基本系: `dp[i] = Σj(dp[j]*Pj + Cj*Pj)`
  - 確率pで成功するミッションを成功するまでトライし続けたとき、トライ回数の期待値は1/pである
    - いわゆる自己遷移である
- dp設計方法
  - 操作で変化するものを考える
  - 状態数を落とすのにグループ化が使えるケースが多い

#### 文字列
- 文字列問題は、文字種に関しては全探索できるケースが多い
  - dpの状態を持つ場合も取りうる文字字種全体を添え字に持つといったことができる
- 部分列問題
  - subarray
    - 条件判定に累積性が必要ないケースが多く、尺取り法などで解けるケースが多い
    - 隣接制約がある場合、開始位置の偶奇で場合分けが可能
  - subsequence
    - 単調性を導出したい時: 位置配列(多くの場合で累積性が不要なケース)
    - 条件判定に累積性が必要な場合が多く、dpを使うことが多い
      - "何文字目まで一致しているか"といった状態を持つことが多い
- 反転系
  - bit列と関連することがしばしば
    - bit列はindexと関連性を持つことが多い
- 辞書順最小問題
  - 前から貪欲に考える
  - "貪欲"に取りたい場合は位置配列が有効

## グラフ理論
- 連結成分問題
  - sccやdsuが絡むことが多い
  - 連結成分の縮約はbool管理よりeraseして再insertの形をとる方が有効
    - sccは縮約だし、dsuは別途setなどで管理する必要がある
    - 縮約した後に新しい連結成分が生まれるのでbool管理は難しい
  - dsuの注意点
    - leaderはmerge後に変化する可能性がある
      - 変数に持ったりmergeを行うループ内でleaderを参照する際は注意する

#### 幾何
- 対称性をうまく使う
- 単調性が絡むケースが非常に多い
- 内包問題
  - 内包されるのが図形の場合は、端点についての点内包問題に帰着させる
- 角度を扱う問題
  - 偏角を考えると、角度配列を作成できて便利
  - atan2で計算できる
  - 角度に関する二分探索は循環させる(剰余を取る)
- 3点を考える場合は、中心の点を固定(全探索)するとよい

## アルゴリズム
#### 全探索
- 異常に制約が小さい変数がある場合は、全探索,全列挙,半分全探索,集合走査(bit全探索)などを疑う
- 組み合わせ型全探索, 構造型全探索, bit全探索など

#### dp
- dpの遷移記述の方式
   1. 到達点への遷移
     - 順方向にdpテーブルを埋めていく
   2. 出発点からの遷移
     - 逆方向にdpテーブルを埋めていく。再帰で書くことが多い
   - 遷移に±両方が絡む場合は再帰で書く
- 自己遷移に注意する、dpは必ず立式してから実装する
- 状態数の絞り方
  - 管理範囲を絞る
  - 管理対象を変更する
    - カテゴリーによるグループ化など
    - 状態の粒度を粗くするイメージ
- 再帰が良いケース
  - ある状態への遷移が±絡む場合
  - 到達しない状態が多いsparseな遷移の場合
- 式変形
  - 高速化
    - 添字と値の入れ替え
    - 半分全列挙
    - 累積構造を活用した区間アルゴリズム(累積和,セグ木など)
    - 漸化式が線形min/maxならConvex Hull Trick
    - スライド最小化: 固定長に対するmin/max
    - 行列累乗への帰着
  - 閉路(自己遷移)の解消
- bitdp
  - 集合sは最終状態でフルになる(全bitが立つ)ように定義すると良い
    - 遷移の方向に注意する。必ずしも集合が増える方向とは限らない
  - 全集合を走査することが多いが、到達しない状態が多いsparseな遷移なら再帰なら計算量を削減できる
    - 再帰はループとは実装は逆方向だが、実際には遷移の方向は同じ
- dpの値にはせいぜい代表値しか持たせられない
  - 位置情報を値として持たせるなら、貪欲に見た最良値などを持たせることが多い
- 木dp
  - 実際に木を構築しても良いが、階層ごとにbottom-upでループする方法もある
    - 分岐が2より大きくノード番号の関係性が扱いにくい場合はループする方が安全

#### 線形スキャン
- 高速化
  - 全てのiで条件を満たすか調べる場合
    - 最悪のケースのみを考える
  - 条件を満たすiの存在性を調べる場合
    - 最良のケースのみを考える
  - 全列挙
    - 線形スキャンするしかない
  - 冗長構造がないか考察
    - 単調性や累積性の導出ができる可能性がある
  - ダブリング
- 配列外参照の防止
  - 番兵法を使うとシンプル

#### 二分探索
- とにかく`単調性`が重要。単調性が成立する,あるいは導出できる状況下では常に可能性を考える
- 何を二分探索するか？
  - 直接情報, 間接情報
- 単調性の導出
  - 隣接要素間でmin/maxを取る
- 偶奇どちらかしか処理できないとき
  - できる限り偶奇制約がない部分を二分探索する
  - 判定関数内だけで1つ厳しくして、最終結果も1つ厳しくする
    - eg) 単調増加で奇数しか処理できない場合、判定関数内で偶数は+1して、最終結果が偶数の場合は+1する

## Tips
- forで取り出す要素がコンテナの場合は、基本は参照にする
- 上限値はヒントの宝庫
- 与えられた配列がsortされいてるのかどうかは常に確認する
