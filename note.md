## ジャンル別
## 数論
- 剰余が絡む問題
- 約数,割り切る等が絡む問題
  - 倍数判定
  - 素数判定
  - 素因数分解
- 周期性が絡む問題
  - まず最初に「周期内での位置」と「何周期目か」を考える
- 桁問題
  - 桁dp
  - 桁dpの枠組みで法則的に解く
  - 全体を数字として扱えない場合も多い。桁ごとに配列や文字列で扱い繰り上げ処理を行うことを考える
- 約数倍数系
  - ある数nの約数dについて、dの倍数にnは必ず含まれる
    - ある集合Aの全要素のgcdについて、gcdの倍数には集合Aの全要素が含まれる
  - 約数と倍数は対をなす概念
    - gcdなど約数を求めるとき、直接求めるのが難しい場合は倍数を考えるのは良い考え
      - 約数は連続じゃないので最適化を二分探索で解く方法は使えないが、倍数を考えるというアプローチはこれと似ている
    - 倍数を考える時に約数を考えるのもまた良い考え
  - 公約数は各要素の素因数分解後の指数のminである
  - 倍数のフルスキャンは調和級数時間になりがち
## 数学的問題
- 方程式系
  - 範囲制約をうまく使って探索することを考える
    - xを直接探索するのではなく置き替え後の変数を探索するなど
  - 二次方程式は解の公式でok
  - 三次以上は区間単調性があるなら二分探索で求解できる

## 組合せ論
- グループ化(パーティション)はベル数もしくはスターリング数を使う
- 重複組合せ
  - (n+k-1)Ck-1: k個に分けるために要素n個とk-1個の仕切りを配置するn+k-1個の位置の中から、k-1個の仕切りの置く場所を選ぶ
- 組合せ論の問題を考える上でのポイント
  - まず制約なしの基礎となるパターンを考える
  - 制約の意味を抽象化し意味を変換する
    - 間隔や差などは、「配置」や「順序」に変換できないか考える
    - 空白を挿入するといった考え方は典型
  - 制約下での自由度を考える
  - 制約を直接数えのが難しい場合は補集合を考える

## 区間処理問題
- 区間伸縮が高速に行える場合
  - 尺取り法, mo's
- 区間mergeが高速に行える場合
  - segtree系, fenwicktree, バケット法
- 区間に単調性を導出できる場合
  - 二分探索(判定問題帰着)
    - 単調性配列を事前計算しておく
- その他: 累積和
- 区間更新
  - 更新区間が連続で重複がない場合は、端点情報さえ持てば十分
  - lazysegtree
- テクニック
  - 直接解を持たせる方法と間接情報を持たせる方法がある
  - 多くの場合で事前計算が絡む
  - 全体が配列で、分割して区間を作る類の問題は、番兵を使うと最終区間を例外なく扱える
  - 座標圧縮
- uniqueは同じ数のnext位置配列が重要

## クエリ問題
- クエリ問題や逐次問題はdpとしての側面を持つ
  - dpは最終状態のみ問われることがほとんど
  - クエリ問題は各クエリでの状態が問われることが多い
    - この場合は順方向に処理せざるを得ない
    - 最終状態のみの場合に、逆方向や再帰での遷移も選択肢になる
      - 状態数を絞りたい: 逆順や再帰で関係ある部分のみトラック
      - 状態更新が複雑: dpで立式
- 処理方式による違い
  - オンライン
  - オフライン
    - sortしたい
    - 後ろから
      - 上書きしていく(歴史をなきものにする)タイプのクエリはこれが使えることが多い
      - 最終状態のみ問われている
- 何を事前計算するかが肝
- クエリの種類が複数がる場合は、何を高速化する必要があるかをまず特定する
- アプローチ方法は大きく2つ
  - 事前計算方式
    - クエリ計算量: O(1)
    - usecase: 静的クエリ,与えられるクエリの範囲が全計算できる場合
    - クエリで与えられる全範囲に対して結果をあらかじめ計算しておく
  - 部分事前計算
    - クエリ計算量: O(logN)
    - usecase: 動的クエリにも対応できる
    - 代表値を保持するデータ構造(segtree,fenwicktree)、あるいは二分探索や累積性が利用できるような配列を作っておく(累積和,単調性配列など)
  - 順序最適化方式
    - クエリをソートして隣接するクエリ間で共通する計算部分を再利用する方法
    - mo's,尺取り法など

## 組合せ最適化問題
- 全探索
  - 組み合わせ制約が隣接要素間の場合は区間アルゴリズムなども使える
- 貪欲法
  - まずは考えやすい特定の条件下で実験してみる
  - コスト関数と目的関数がそれぞれの最適化方向に対して広義単調性をもつ
    - ナップサック問題と類似の構造を持つ場合はこれをチェックすると良い
    - 「価格が安いほど価値が小さくない」
- dp
  - 遷移の方向を規定できる(eg.文字列,逐次問題など)
    - 貪欲法と組合せることで、本来は方向を規定できない問題にも適用できる
    - bitdpは集合を扱う必要がある時に使うが、貪欲に処理できるならその瞬間瞬間でそれを選択するかどうかを判断すればいいだけなので、集合管理が不要になる
  - 影響が累積的
- グラフ
  - 大前提、nwフロー系以外で使えるケースは限定的
  - グラフ化した時に木やfunctionalグラフにならないかまず考える
    - これらはdpに帰着できる
  - 組合せ制約が任意の要素間に及び、直接dpの適用が難しいケース
- 判定問題帰着
  - 単調性がある時に使える
  - 直接最適性を求めるのは難しいが、判定は高速に行える場合
  - 最小の最大化
  - 複数種類を同時最適化する場合
    - 部分問題間の依存性が弱い場合は判定問題で解ける(判定問題にすることで独立に扱える)
      - 部分問題間の依存性が弱いとは: 合計値やリソース総量などの関係性のみの場合
    - 1つを固定する
      - 扱いにくい方を固定する
- 補集合を考える
  - 最小化は逆の操作の最大化の方が簡単だったりしないか？
    - eg) 削除回数の最小化->最大構築サイズ
- ダブリング
  - 各要素が独立に選択可能で、同種の要素が複数あるとき、塊で扱うという考え方ができる

## 逐次問題
- 貪欲法
- dp
- グラフ
- データ構造
  - stack+popは単調性作出に便利
- ダブリング
  - 目的地まで一気に進めるという考え方
- テクニック
  - 求める時刻はいつか？
    - 全ての時刻
    - クエリで与えられた時刻
    - 無限時間後
      - 順序依存性がない時、逐次操作をtrackする必要はなく、バッチ的に求められることが多い
  - 未来への影響管理
    - ある時点の影響が未来に及ぶ時、未来に対して情報を先に記録する/遅延する
  - 過去への影響管理
    - ある時点の過去全てを更新するような操作の場合は、比較対象側を更新し、新たにシミュレートする要素はoffsetを加える。
      - つまり「相対関係は崩さない」ことを前提に更新対象を変えるテクニック
  - 変化する対象が複数ある場合
    - 順序構造が変化することがあるか確認する
    - 影響がある(考慮する必要がある)対象を特定する
  - 逆順に考えた方が良いケースもある
    - 最終的な状態から操作を取り消していくことを考える
    - 挿入操作 <=> 削除操作 考えやすい方に注目する
- 動的に何らかしらの情報を伝播することが多い
  - 端点情報など代表値ならmin/max, 区間情報ならfenwicktree, 既出管理ならmap,setなど
- 逐次問題はイベントが発生する点のみを考えるという発想は重要

## 数え上げ
- 単調性が条件にある場合: 二分探索が使えるデータ構造を使う
  - 静的: vectorをsort
  - 動的かつ削除可: set,multiset,priority_queue
    - left,rightを指定したいならset, leftは常に先頭でrightを指定したいならpriority_queue
  - 動的かつ削除不可: fenwick_tree
    - fenwickは個数管理に使える。内部は位置配列を持たせる
      - 動的に更新できるので、すでに見た中でx以下の個数などを高速に計算できる
    - 転倒数は典型的な用途の一つ
- 区間,位置数え上げ
  - offsetを前処理で消すと楽
  - fenwicktreeによる高速化ができないか検討する
  - sortやswapにより条件をシンプルにすることを考える
  - event drivenな走査は多くのコーナーケースを産むので、実行時間が許すなら位置配列などに記録し線形にスキャンするべき
- カウント配列
- 全ペア数え上げ問題
  - そもそもペアの生成が間に合わない場合
    - 数式変形
      - 単一のΣにしか依存しない形に変形する
      - 剰余が数式にあるなら場合分けして剰余を消すことも検討する
    - 逆転の発想をする
      - 全ペアを走査して条件を満たすものを数え上げる <=> 全条件を走査してそれに合致するペアを数え上げる
    - 対称なものをまとめて計算する
      - 剰余が絡むなら余りで分類すると良い
    - 最終求めるものの形式に合わせて使えそうな高速化を念頭におく
      - eg) 総和を求める問題なら、累積和とか使えるかも？と考える
  - 各クエリが間に合わない場合
  - 各要素の値が連続なら、格子点とみなせる
    - 各格子点へのパスを限定することで計算量を落とせる場合がある
- 条件式が複数ある場合
  - 補集合により簡単な条件に変換できないか考える
    - 特にnot条件が絡む場合
  - 条件的に厳しいのはどれか？を考えると良い
  - 一部の条件については全探索をすることも考える

## ソート/配置問題
- Σ|p[i]-t|を最小にするtは中央値であることは有名事実
- 位置オフセットの調整
  - ある種の要素の大きさを無視したい時、オフセットを引くことで大きさをなくし、凝集する際に1点凝集と捉えることができる
    - 連続性が要求される配置問題
    - 隣接交換を行う問題

## 構築問題
- 解が一意の場合
- 解が無数にある場合
  - 全列挙なら法則を見抜いて全探索する
  - 1つで良いなら最も考えやすい形について調べる

## ゲーム問題
- 基本方針
  - 各局面の状態の表現方法を考える
    - 存在性: 2進数
    - 存在場所,より詳細な状態など3値以上のパターンを取りうる場合: 3進数, 各パターンをtupleで別々にvectorなどで保持
  - メモ化再帰 f(s):=状態sからスタートして遷移先で、少なくとも1つ相手が負ける選択肢があるか を定義する
    - 状態sで操作しうる選択肢を全探索する

## 確率,期待値問題
- 「独立性」を考えることが最も重要
  - どの操作とどの操作が独立なのか、状態に依存するのか、その状態はどう遷移するのか
- 確率問題
  - 基本系: `dp[i] = Σj(dp[j]*Pj)`
  - 純粋に場合の数を数え上げる問題も存在する。制約を常に注視する。
  - 「一様性の仮定」を疑うこと
    - 重複や同一性がある場合は特に注意
    - dpを使う問題など、操作結果が状態に依存する問題も一様性が成立しない典型
  - 逐次操作系は常に逆方向から考えることも検討する
    - 逆方向から考える時は基本「残り」を状態とする
  - 逐次操作系はまず終了条件を考察する
    - 終了の直前に満たすべき条件などが重要になるケースがしばしば
  
- 期待値問題
  - 基本系: `dp[i] = Σj(dp[j]*Pj + Cj*Pj)`
  - 確率pで成功するミッションを成功するまでトライし続けたとき、トライ回数の期待値は1/pである
    - いわゆる自己遷移である
- dp設計方法
  - 操作で変化するものを考える
  - 状態数を落とすのにグループ化が使えるケースが多い

## 文字列
- 文字列問題は、文字種に関しては全探索できるケースが多い
  - dpの状態を持つ場合も取りうる文字字種全体を添え字に持つといったことができる
- 部分列問題
  - subarray
    - 条件判定に累積性が必要ないケースが多く、尺取り法などで解けるケースが多い
    - 隣接制約がある場合、開始位置の偶奇で場合分けが可能
  - subsequence
    - 単調性を導出したい時: 位置配列(多くの場合で累積性が不要なケース)
    - 条件判定に累積性が必要な場合が多く、dpを使うことが多い
      - "何文字目まで一致しているか"といった状態を持つことが多い
- 反転系
  - bit列と関連することがしばしば
    - bit列はindexと関連性を持つことが多い
- 辞書順最小問題
  - 前から貪欲に考える
  - "貪欲"に取りたい場合は位置配列が有効
- 回文
  - 中央から伸長していく戦略もある
  - https://blog.hamayanhamayan.com/entry/2017/03/25/005452
- 文字列操作系アルゴリズム
  - manacher: 各文字を中心とする回文半径を求める(O(N))
  - z-algorithm:
    - sとs[i:|s|-1]の最長共通prefixを求める(O(N))
    - 反転文字を先頭に連結した文字列を考えることで、suffix回文に応用できる
  - rolling-hash
  - kmp
  - trie
  - suffix-array
  - lcp

## グラフ理論
- 連結成分問題
  - sccやdsuが絡むことが多い
  - 連結成分の縮約はbool管理よりeraseして再insertの形をとる方が有効
    - sccは縮約だし、dsuは別途setなどで管理する必要がある
    - 縮約した後に新しい連結成分が生まれるのでbool管理は難しい
  - UnionFindについて
    - leaderはmerge後に変化する可能性がある
      - 変数に持ったりmergeを行うループ内でleaderを参照する際は注意する
    - 連結を分離させていく操作は、時間を逆に見て連結させていく操作で考える
    - UnionFindに情報を持たせたい場合は、leader番号をindexに持つ配列を用意する
  - グラフにおける同一構造は縮約して考えることを検討する
- 経路探索問題
  - 多くの場合、木DPで解ける
    - 適当なLCAを決めて木DPする
    - 木DPは基本bottom-upなので、dfsの帰りがけで処理を行う
    - 複数の子からの情報の扱いが重要。累積的に使うのか組み合わせ的に使うのかなど
  - 始点からの処理結果と、終点からの処理結果をmergeして求解する方法を取ることがしばしばある
    - 経由地最短路問題など
- bfs
  - 重み付きbfs
    - bfsは重みが一定の遷移である必要がある。それ以外の重みは多始点bfsの初期状態として予め入れておけるなら扱える
      - 特殊なグラフを扱う場合は、bfsやdfsなどグラフの遷移時に必要な情報は何か？を考えてグラフを定義すると良い。
  - edgeを頂点とみなすようなグラフはよくある
- dfs
  - 木を1次元配列的に捉えることができる
  - 木上で累積和を取りたいケースなどで有効
- 普通にやったら考慮してしまう部分を無視したい場合、前処理で属性変更するのは有効な手段

## 幾何
- 対称性をうまく使う
- 単調性が絡むケースが非常に多い
- 内包問題
  - 内包されるのが図形の場合は、端点についての点内包問題に帰着させる
- 角度を扱う問題
  - 偏角を考えると、角度配列を作成できて便利
  - atan2で計算できる
    - y,xが分かれば求められる(cos,sinを求める必要がない)
  - 角度に関する二分探索は循環させる(剰余を取る)
- 3点を考える場合は、中心の点を固定(全探索)するとよい

## グリッド問題
- sortしてスキャンする行為は逐次操作である

# アルゴリズム
## 全探索
- 異常に制約が小さい変数がある場合は、全探索,全列挙,半分全探索,集合走査(bit全探索)などを疑う
- 組み合わせ型全探索, 構造型全探索, bit全探索など
- 集合数が固定の全探索は、「残り」を考えることで全探索対象の集合を減らせる

## dp
- dpの遷移記述の方式
   1. 到達点への遷移
     - 順方向にdpテーブルを埋めていく
   2. 出発点からの遷移
     - 逆方向にdpテーブルを埋めていく。再帰で書くことが多い
   - 遷移に±両方が絡む場合は再帰で書く
- 自己遷移に注意する、dpは必ず立式してから実装する
- 状態数の絞り方
  - 管理範囲を絞る
  - 管理対象を変更する
    - カテゴリーによるグループ化など
    - 状態の粒度を粗くするイメージ
- 再帰が良いケース
  - ある状態への遷移が±絡む場合
  - 到達しない状態が多いsparseな遷移の場合
- 式変形
  - 高速化
    - 添字と値の入れ替え
    - 半分全列挙
    - 累積構造を活用した区間アルゴリズム(累積和,セグ木など)
    - 漸化式が線形min/maxならConvex Hull Trick
    - スライド最小化: 固定長に対するmin/max
    - 行列累乗への帰着
  - 閉路(自己遷移)の解消
- bitdp
  - 集合sは最終状態でフルになる(全bitが立つ)ように定義すると良い
    - 遷移の方向に注意する。必ずしも集合が増える方向とは限らない
  - 全集合を走査することが多いが、到達しない状態が多いsparseな遷移なら再帰なら計算量を削減できる
    - 再帰はループとは実装は逆方向だが、実際には遷移の方向は同じ
  - bitdpは常に特定の範囲をbit全探索している意識を持つ。sparseなら事前計算で計算量が落とせる
    - sparseと座標圧縮はセットで考える
    - indexはpopcountで代用できないか一旦考える
- dpの値にはせいぜい代表値しか持たせられない
  - 位置情報を値として持たせるなら、貪欲に見た最良値などを持たせることが多い
- 木dp
  - 実際に木を構築しても良いが、階層ごとにbottom-upでループする方法もある
    - 分岐が2より大きくノード番号の関係性が扱いにくい場合はループする方が安全
  - 木dpをする上で重要なのは2つ
    - 何を伝播させるか
    - いつansを更新するか
      - 特に最終的な状態ではなく、特定の部分木が解になるケースではこれが重要
- 区間dp
  - O(N^2)程度になることが多いので、ある程度Nが小さい必要がある
  - 区間の除去/縮約など
- バンドdp
  - 動かすindexが2つある時、片方の状態を±dの範囲に限定する方法

## 線形スキャン
- 高速化
  - 全てのiで条件を満たすか調べる場合
    - 最悪のケースのみを考える
  - 条件を満たすiの存在性を調べる場合
    - 最良のケースのみを考える
  - 全列挙
    - 線形スキャンするしかない
  - 冗長構造がないか考察
    - 単調性や累積性の導出ができる可能性がある
  - ダブリング
- 配列外参照の防止
  - 番兵法を使うとシンプル

## 二分探索
- とにかく`単調性`が重要。単調性が成立する,あるいは導出できる状況下では常に可能性を考える
- 何を二分探索するか？
  - 直接情報, 間接情報
- 単調性の導出
  - 隣接要素間でmin/maxを取る
- 偶奇どちらかしか処理できないとき
  - できる限り偶奇制約がない部分を二分探索する
  - 判定関数内だけで1つ厳しくして、最終結果も1つ厳しくする
    - eg) 単調増加で奇数しか処理できない場合、判定関数内で偶数は+1して、最終結果が偶数の場合は+1する
- 「最も近いもの(距離)」を探索する場合は番兵を入れると良い

# Tips
- forで取り出す要素がコンテナの場合は、基本は参照にする
- 対称な条件がある場合は、swapで省略できないか考える
  - 挿入と削除など
- erase操作を行う時は条件判定を特に気をつける
- mapは重い。際どいループ内では極力避ける
- 想定アルゴリズムは典型だが、それを隠蔽するものがいくつも織り混ぜされることが多い
  - 補集合, 特殊グラフ, 単調性など
  - 作題者の意図を読み解くことが重要
- 距離を求める系の問題は並行移動やswapで計算量を落とせないか検討する
