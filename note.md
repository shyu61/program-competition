## ジャンル別
- 数論
  - 剰余が絡む問題
  - 約数,割り切る等が絡む問題
    - 倍数判定
    - 素数判定
    - 素因数分解
  - 周期性が絡む問題
  - 桁が絡む問題
    - 桁dp
    - 桁dpの枠組みで法則的に解く

- 区間処理
  - 区間伸縮が高速に行える場合: 尺取り法, mo's
  - 区間mergeが高速に行える場合: segtree, バケット法
  - 全体を事前計算できる場合: 累積和
  - テクニック
    - 直接解を持たせる方法と間接情報を持たせる方法がある
    - 多くの場合で事前計算が絡む

- 組合せ最適化問題
  - 全探索: 組み合わせ型全探索 と 構造型全探索がある
    - 組み合わせ制約が隣接要素間の場合は区間アルゴリズムなども使える
  - 貪欲法
  - dp
    - 遷移の方向を規定できる(eg.文字列,逐次問題など)
    - 影響が累積的(現在の選択が過去の選択を元に決定できる)
  - グラフ
    - 組み合わせ制約が任意の要素間に及び、直接dpの適用が難しいケース
    - グラフに直した時、木やfunctionalグラフになる場合はdpに帰着できる
    - nwフロー以外でのグラフの組み合わせ最適化手法はかなり限定的
  - 判定問題への帰着
    - 直接最適性を求めるのは難しいが、判定は高速に行える場合
  - 補集合を考える
    - 最小化は逆の操作の最大化の方が簡単だったりしないか？
      - eg) 削除回数の最小化->最大構築サイズ

- 逐次処理問題
  - データ構造を活用する: stackなど
  - 求める時刻はいつか？
    - 全ての時刻 or クエリで与えられた時刻 or 無限時間後
  - trackすべき対象が複数あるときは、冗長構造がないか考える
  - テクニック
    - 未来への影響管理: ある時点の影響が未来に及ぶ時、未来に対して情報を先に記録する/遅延する

- 数え上げ
  - 単調性が条件にある場合: 二分探索が使えるデータ構造を使う
    - 静的: vectorをsort
    - 動的かつ削除可: set,multiset,priority_queue
      - left,rightを指定したいならset, leftは常に先頭でrightを指定したいならpriority_queue
    - 動的かつ削除不可: fenwick_tree
  - 区間数え上げ
    - 使えるテクニック: offset
  - カウント配列

- 構築問題
  - 解が一意の場合
  - 解が無数にある場合
    - 全列挙なら法則を見抜いて全探索する
    - 1つで良いなら最も考えやすい形について調べる

- ゲーム問題
- 確率,期待値問題
  - 確率問題の基本系: `dp[i+1] = Σj(dp[j]*Pj)`
  - 期待値問題の基本系: `dp[i+1] = Σj(dp[j]*Pj + Cj*Pj)`
  - dp設計方法
    - 操作で変化するものを考える
    - 状態数を落とすのにグループ化が使えるケースが多い
    - 「ある状態への遷移」か「ある状態からの遷移か」。一般的なdpはほぼ前者だが、期待値dpは後者を取るケースも多い
- 文字列
  - 部分列問題
    - subarray
      - 条件判定に累積性が必要ないケースが多く、尺取り法などで解けるケースが多い
      - 隣接制約がある場合、開始位置の偶奇で場合分けが可能
    - subsequence
      - 条件判定に累積性が必要な場合が多く、dpを使うことが多い
- 幾何
- dp
  - 状態数の絞り方
    - 管理範囲を絞る
    - 管理対象を変更する(カテゴリーによるグループ化など)
  - ループvsメモ化再帰
    - ある状態への遷移が±絡む場合は再帰を使う方が安全

## テクニック
- dpの式変形
  - 高速化目的
    - 累積構造を活用した区間アルゴリズム(累積和,セグ木など)
    - 漸化式が線形min/maxならConvex Hull Trick
    - 行列累乗への帰着
  - 閉路(自己遷移)解消目的
- 線形スキャン
  - 高速化
    - 全てのiについて条件を満たすかを調べる場合: 最悪のケースのみを考える
    - 条件を満たすiが存在するか調べる場合: 最良のケースのみを考える
    - 全列挙など: 線形スキャンするしかない
    - 冗長構造がないか考察
      - 単調性や累積性の導出ができる可能性がある
  - 配列外参照の防止
    - 番兵法を使うとシンプル
- 単調性の導出
  - 隣接要素間でmin/maxを取る
