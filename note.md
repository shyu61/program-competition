## ジャンル別
- 数論
  - 剰余が絡む問題
  - 約数,割り切る等が絡む問題
    - 倍数判定
    - 素数判定
    - 素因数分解
  - 周期性が絡む問題
  - 桁が絡む問題
    - 桁dp
    - 桁dpの枠組みで法則的に解く

- 区間処理(区間クエリ問題も含む)
  - 区間伸縮が高速に行える場合: 尺取り法, mo's
    - 事前計算: 不要
  - 区間mergeが高速に行える場合: segtree, fenwickgree, バケット法, lazysegtree
    - 事前計算: 木もしくはバケット
  - 区間に何らかの単調性を導出できる場合: 二分探索(判定問題帰着)
    - 事前計算: 単調性配列
  - その他: 累積和
  - テクニック
    - 直接解を持たせる方法と間接情報を持たせる方法がある
    - 多くの場合で事前計算が絡む

- クエリ問題
  - オンライン高速化
    - 各クエリをなんとか高速化(データ構造,二分探索が絡むことが多い)
  - オフライン高速化
    - (ソートして)累積的に解く
    - クエリをバッチ的に処理
  - いずれも何を事前計算するか？が重要

- 組合せ最適化問題
  - 全探索: 組み合わせ型全探索 と 構造型全探索がある
    - 組み合わせ制約が隣接要素間の場合は区間アルゴリズムなども使える
  - 貪欲法
    - コスト関数と目的関数がそれぞれの最適化方向に対して広義単調性をもつ
      - ナップサック問題と類似の構造を持つ場合はこれをチェックすると良い
      - 「価格が安いほど価値が小さくない」
  - dp
    - 遷移の方向を規定できる(eg.文字列,逐次問題など)
    - 影響が累積的(現在の選択が過去の選択を元に決定できる)
  - グラフ
    - 組み合わせ制約が任意の要素間に及び、直接dpの適用が難しいケース
    - グラフに直した時、木やfunctionalグラフになる場合はdpに帰着できる
    - nwフロー以外でのグラフの組み合わせ最適化手法はかなり限定的
  - 判定問題への帰着
    - 直接最適性を求めるのは難しいが、判定は高速に行える場合
  - 補集合を考える
    - 最小化は逆の操作の最大化の方が簡単だったりしないか？
      - eg) 削除回数の最小化->最大構築サイズ
  - ダブリング
    - 各要素が独立に選択可能で、同種の要素が複数あるとき、塊で扱うという考え方ができる
  - 最小の最大化: 二分探索をする

- 逐次処理問題
  - データ構造を活用する
    - stackなど
  - 求める時刻はいつか？
    - 全ての時刻 or クエリで与えられた時刻 or 無限時間後
  - trackすべき対象が複数あるときは、冗長構造がないか考える
  - ダブリングを使った高速化
    - 目的地まで一気に進めるという考え方
  - テクニック
    - 未来への影響管理: ある時点の影響が未来に及ぶ時、未来に対して情報を先に記録する/遅延する

- 数え上げ
  - 単調性が条件にある場合: 二分探索が使えるデータ構造を使う
    - 静的: vectorをsort
    - 動的かつ削除可: set,multiset,priority_queue
      - left,rightを指定したいならset, leftは常に先頭でrightを指定したいならpriority_queue
    - 動的かつ削除不可: fenwick_tree
  - 区間数え上げ
    - 使えるテクニック: offset
  - カウント配列
  - 全ペア数え上げ問題
    - 逆転の発想をするとよい
      - 全ペアを走査して条件を満たすものを数え上げる <=> 全条件を走査してそれに合致するペアを数え上げる
  - 補集合を考える
    - 特にnot条件が絡む場合

- 構築問題
  - 解が一意の場合
  - 解が無数にある場合
    - 全列挙なら法則を見抜いて全探索する
    - 1つで良いなら最も考えやすい形について調べる

- ゲーム問題
- 確率,期待値問題
  - 確率問題の基本系: `dp[i+1] = Σj(dp[j]*Pj)`
  - 期待値問題の基本系: `dp[i+1] = Σj(dp[j]*Pj + Cj*Pj)`
  - dp設計方法
    - 操作で変化するものを考える
    - 状態数を落とすのにグループ化が使えるケースが多い
    - 「ある状態への遷移」か「ある状態からの遷移か」。一般的なdpはほぼ前者だが、期待値dpは後者を取るケースも多い
- 文字列
  - 部分列問題
    - subarray
      - 条件判定に累積性が必要ないケースが多く、尺取り法などで解けるケースが多い
      - 隣接制約がある場合、開始位置の偶奇で場合分けが可能
    - subsequence
      - 単調性を導出したい時: 位置配列(多くの場合で累積性が不要なケース)
      - 条件判定に累積性が必要な場合が多く、dpを使うことが多い
- 幾何
  - 対称性をうまく使う
  - 単調性が絡むケースが非常に多い
  - 内包問題
    - 内包されるのが図形の場合は、端点についての点内包問題に帰着させる

## アルゴリズム
- dp
  - 状態数の絞り方
    - 管理範囲を絞る
    - 管理対象を変更する(カテゴリーによるグループ化など)
  - ループvsメモ化再帰
    - ある状態への遷移が±絡む場合は再帰を使う方が安全
  - 式変形
    - 高速化
      - 添字と値の入れ替え
      - 半分全列挙
      - 累積構造を活用した区間アルゴリズム(累積和,セグ木など)
      - 漸化式が線形min/maxならConvex Hull Trick
      - スライド最小化: 固定長に対するmin/max
      - 行列累乗への帰着
    - 閉路(自己遷移)の解消

- 線形スキャン
  - 高速化
    - 全てのiで条件を満たすか調べる場合
      - 最悪のケースのみを考える
    - 条件を満たすiの存在性を調べる場合
      - 最良のケースのみを考える
    - 全列挙
      - 線形スキャンするしかない
    - 冗長構造がないか考察
      - 単調性や累積性の導出ができる可能性がある
    - ダブリング
  - 配列外参照の防止
    - 番兵法を使うとシンプル

- 二分探索
  - とにかく`単調性`が重要。単調性が成立する,あるいは導出できる状況下では常に可能性を考える
  - 何を二分探索するか？
    - 直接情報, 間接情報
  - 単調性の導出
    - 隣接要素間でmin/maxを取る
  - 偶奇どちらかしか処理できないとき
    - できる限り偶奇制約がない部分を二分探索する
    - 判定関数内だけで1つ厳しくして、最終結果も1つ厳しくする
      - eg) 単調増加で奇数しか処理できない場合、判定関数内で偶数は+1して、最終結果が偶数の場合は+1する
